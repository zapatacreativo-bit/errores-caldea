-- ============================================
-- ESQUEMA DE BASE DE DATOS - AUDITORÍA SEO CALDEA
-- ============================================
-- Ejecutar este script en el SQL Editor de Supabase

-- 0. Limpieza (CUIDADO: Esto borra los datos existentes)
DROP TABLE IF EXISTS audit_urls CASCADE;
DROP TABLE IF EXISTS issue_types CASCADE;
DROP TABLE IF EXISTS categories CASCADE;

-- 1. Tabla de Categorías (Indexación, Contenido, etc.)
CREATE TABLE categories (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  slug TEXT NOT NULL UNIQUE,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 2. Tabla de Tipos de Problemas (Definición de errores)
CREATE TABLE issue_types (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  category_id BIGINT REFERENCES categories(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  priority TEXT CHECK (priority IN ('High', 'Medium', 'Low')),
  description TEXT,
  total_count INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 3. Tabla de URLs (El detalle de cada error a reparar)
CREATE TABLE audit_urls (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  issue_type_id BIGINT REFERENCES issue_types(id) ON DELETE CASCADE,
  url TEXT NOT NULL,
  linked_from TEXT, -- URL de origen donde se encontró el error
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'fixed', 'ignored')),
  fixed_by UUID REFERENCES auth.users(id), -- Usuario que marcó el fix
  fixed_at TIMESTAMPTZ, -- Fecha de la reparación
  notes TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 4. Índices para mejorar el rendimiento
CREATE INDEX idx_audit_urls_issue_type ON audit_urls(issue_type_id);
CREATE INDEX idx_audit_urls_status ON audit_urls(status);
CREATE INDEX idx_issue_types_category ON issue_types(category_id);
CREATE INDEX idx_issue_types_priority ON issue_types(priority);

-- 5. Habilitar Row Level Security (RLS) para seguridad
ALTER TABLE categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE issue_types ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_urls ENABLE ROW LEVEL SECURITY;

-- Políticas: Solo usuarios autenticados pueden ver y editar
CREATE POLICY "Usuarios autenticados pueden ver categorías" 
  ON categories FOR SELECT 
  USING (auth.role() = 'authenticated');

CREATE POLICY "Usuarios autenticados pueden ver tipos de error" 
  ON issue_types FOR SELECT 
  USING (auth.role() = 'authenticated');

CREATE POLICY "Usuarios autenticados pueden ver URLs" 
  ON audit_urls FOR SELECT 
  USING (auth.role() = 'authenticated');

CREATE POLICY "Usuarios autenticados pueden actualizar URLs" 
  ON audit_urls FOR UPDATE 
  USING (auth.role() = 'authenticated');

-- 6. Función para actualizar timestamp automáticamente
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- 7. Trigger para actualizar updated_at en audit_urls
CREATE TRIGGER update_audit_urls_updated_at 
  BEFORE UPDATE ON audit_urls 
  FOR EACH ROW 
  EXECUTE FUNCTION update_updated_at_column();

-- ============================================
-- DATOS SEMILLA (SEED DATA)
-- ============================================

-- Insertar Categorías
INSERT INTO categories (name, slug) VALUES 
('Indexación', 'indexing'), 
('Técnico', 'technical'), 
('Contenido', 'content'), 
('Imágenes', 'images'), 
('Localización', 'localization'),
('Enlaces', 'links');

-- Insertar Tipos de Error (Basados en la auditoría de Caldea)
INSERT INTO issue_types (category_id, title, priority, description, total_count) VALUES 
-- Indexación
(1, 'Errores 4xx (Enlaces rotos)', 'High', 'Enlaces rotos hacia recursos internos o externos que devuelven error 404.', 2985),
(1, 'Errores 5xx (Servidor)', 'High', 'Errores del servidor que impiden el acceso a recursos.', 1),
(1, 'Páginas restringidas (Robots/Noindex)', 'Medium', 'Páginas bloqueadas por robots.txt o meta noindex.', 15001),

-- Técnico
(2, 'Redirecciones 302 (Temporales)', 'Medium', 'Redirecciones temporales que deberían ser permanentes (301).', 389),
(2, 'Redirecciones 301 (Permanentes)', 'Low', 'Redirecciones permanentes que deben verificarse.', 1376),
(2, 'Cadenas de redirección largas', 'Medium', 'Múltiples redirecciones en cadena que afectan el rendimiento.', 466),

-- Contenido
(3, 'Títulos duplicados', 'High', 'Mismo título <title> en múltiples páginas.', 85),
(3, 'Títulos vacíos', 'High', 'Páginas sin etiqueta <title>.', 29),
(3, 'Meta descripciones duplicadas', 'Medium', 'Misma meta description en varias páginas.', 76),
(3, 'Títulos/Metas demasiado largos', 'Low', 'Títulos o descripciones que exceden la longitud recomendada.', 240),

-- Imágenes
(4, 'Imágenes rotas', 'High', 'Imágenes que devuelven error de carga.', 71),
(4, 'Texto ALT vacío', 'Medium', 'Imágenes sin descripción alternativa (atributo alt).', 42092),

-- Localización
(5, 'Enlaces de retorno perdidos (Hreflang)', 'Medium', 'Etiquetas hreflang sin reciprocidad.', 401),
(5, 'Falta valor "x-default" (Hreflang)', 'Medium', 'Ausencia de etiqueta x-default en implementación hreflang.', 258),

-- Enlaces
(6, 'Enlaces de retroceso', 'Medium', 'Auditoría de enlaces de retroceso (Backlinks).', 0);

-- ============================================
-- VISTAS ÚTILES PARA REPORTES
-- ============================================

-- Vista: Resumen de progreso por categoría
CREATE OR REPLACE VIEW v_category_progress AS
SELECT 
  c.name AS category_name,
  c.slug AS category_slug,
  COUNT(DISTINCT it.id) AS total_issue_types,
  SUM(it.total_count) AS total_urls,
  COUNT(CASE WHEN au.status = 'fixed' THEN 1 END) AS fixed_count,
  COUNT(CASE WHEN au.status = 'pending' THEN 1 END) AS pending_count,
  ROUND(
    (COUNT(CASE WHEN au.status = 'fixed' THEN 1 END)::DECIMAL / 
     NULLIF(COUNT(au.id), 0) * 100), 2
  ) AS completion_percentage
FROM categories c
LEFT JOIN issue_types it ON c.id = it.category_id
LEFT JOIN audit_urls au ON it.id = au.issue_type_id
GROUP BY c.id, c.name, c.slug
ORDER BY c.id;

-- Vista: Tipos de error con estadísticas
CREATE OR REPLACE VIEW v_issue_stats AS
SELECT 
  it.id,
  it.title,
  it.priority,
  it.description,
  c.name AS category_name,
  it.total_count,
  COUNT(CASE WHEN au.status = 'fixed' THEN 1 END) AS fixed_count,
  COUNT(CASE WHEN au.status = 'pending' THEN 1 END) AS pending_count,
  COUNT(CASE WHEN au.status = 'ignored' THEN 1 END) AS ignored_count
FROM issue_types it
LEFT JOIN categories c ON it.category_id = c.id
LEFT JOIN audit_urls au ON it.id = au.issue_type_id
GROUP BY it.id, it.title, it.priority, it.description, c.name, it.total_count
ORDER BY 
  CASE it.priority 
    WHEN 'High' THEN 1 
    WHEN 'Medium' THEN 2 
    WHEN 'Low' THEN 3 
  END,
  it.total_count DESC;
